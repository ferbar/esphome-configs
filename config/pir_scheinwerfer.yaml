substitutions:
  devicename: "pir_scheinwerfer"
  upper_devicename: "PIR Scheinwerfer"

esphome:
  name: $devicename

esp8266:
  board: esp01
#  board: d1_mini_pro

<<: !include common/base.yaml

#globals:
#  - id: output_mode
#    type: bool
#    initial_value: "true"

binary_sensor:
  - !include common/base-binarysensor-status.yaml
  - platform: gpio
    pin:
      number: 3
      inverted: true
    name: "${upper_devicename} motion"
    device_class: motion
    on_press:
      then:
        - lambda: |-
            ESP_LOGW("pir", "on");
            ESP_LOGW("mode", "%s", id(output_mode).state.c_str());
            if( id(output_mode).state == "auto") {
              ESP_LOGW("muh", "lampe).turn_on()");
              id(lampe).turn_on().perform();
            }
    on_release:
      then:
        - lambda: |-
            ESP_LOGW("pir", "off");
            ESP_LOGW(__FILE__, "mode: %s", id(output_mode).state.c_str());
            if( id(output_mode).state == "auto") {
              ESP_LOGW(__FILE__, "lampe).turn_off()");
              id(lampe).turn_off().perform();
            }

sensor:
  - !include common/base-sensor-wifi.yaml
  - !include common/base-sensor-uptime.yaml
  - !include common/base-sensor-vcc.yaml
#  - platform: wifi_signal
#    name: esphome_pir_scheinwerfer_wifi_signal
#    update_interval: 10s
#  - platform: uptime
#    name: esphome_pir_scheinwerfer_uptime

switch:
  - !include common/base-switch-reset.yaml

#  - platform: template
#    name: "${upper_devicename} light"
#    id: light_switch
##    output: 'gpio_out'
##    optimistic: true
#    lambda: |-
#      return id(gpio_out).state;
#    turn_on_action:
#        - lambda: |-
#            ESP_LOGW("pir", "on");
#            if( id(output_mode).state == "auto" || id(output_mode).state == "manuell" ) {
#              id(gpio_out).turn_on();
#            }
#    turn_off_action:
#        - lambda: |-
#            ESP_LOGW("pir", "off");
#            if( id(output_mode).state == "auto" || id(output_mode).state == "manuell" ) {
#              id(gpio_out).turn_off();
#            }

select:
  - platform: template
    id: output_mode
#    entity_id: switch.${devicename}_auto_mode
    name: "${upper_devicename} Scheinwerfermodus"
    optimistic: true
    options:
      - auto
      - manuell
#      - always_on
#      - always_off
    initial_option: auto
    on_value:
      then:
        - logger.log:
            format: "Chosen option: %s (index %d)"
            args: ["x.c_str()", "i"]
        - lambda: |-
            switch(i) {
                // status lesen funktioniert nicht
                // case 0: id(light_switch).state = id(gpio_out).current_values.state(); break;
                // case 1: id(light_switch).state = id(gpio_out).current_values.state; break;
              // case 1: id(lampe).turn_on(); break;
              // case 2: id(lampe).turn_off(); break;
            }
#      lambda: |-
#        ESP_LOGW("output mode", "turn off");
#        id(output_mode)=false;
         

#    device_class: 
#    restore_mode: ALWAYS_ON
#    lambda: |-
#      return id(output_mode);
#    turn_on_action:
#      lambda: |-
#        ESP_LOGW("output mode", "turn on");
#        id(output_mode)=true;
#    turn_off_action:
#      lambda: |-
#        ESP_LOGW("output mode", "turn off");
#        id(output_mode)=false;



output:
  - platform: gpio
    #inverted: true
    id: lampe_output
    pin:
      number: GPIO2
#      inverted: true

light:

  - platform: binary
    name: "${upper_devicename} Scheinwerfer"
    output: lampe_output
    id: lampe


  - platform: status_led
    name: "${upper_devicename} Status LED"
    pin:
      number: GPIO1
      inverted: true

